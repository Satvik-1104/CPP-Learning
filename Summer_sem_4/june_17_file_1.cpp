// Function Templates - function blueprints
// Used when we need many number of overloads of a function.
// It would take so long to type all the overloads, function templates help with this
// They help on avoiding code repetition
// Function Templates are not pure C++ code, they are just blueprints that generates the function based on the arguments passed
// The real C++ code generated by a template is called a template instance
// No duplicates of a template instance will be created, the already existing ones will be reused

/*
function template declaration and defintion

template <typename T> T maximum (T a, T b);          -> declaration
template <typename T> T maximum (T a, T b)
{
    return (a > b) ? a : b;
}

*/

#include <iostream>
#include <string>
#include <cstring>
#include <typeinfo>
using namespace std;

template <typename T>
T maximum_value (T a, T b)
{
    cout << "In function:       & " << a << ": " << &a << "     & " << b << ": " << &b << endl;
    return (a > b) ? a : b;
}

template <typename T>
T& maximum_reference (T& a, T& b)
{
    cout << "In function:       & " << a << ": " << &a << "     & " << b << ": " << &b << endl;
    return (a > b) ? a : b;
}

template <typename T>
T maximum_char (T a, T b)
{
    return (a > b) ? a : b;
}

template <>
const char * maximum_char <const char *> (const char * a, const char * b)
{
    return (strcmp (a, b) > 0) ? a : b;
}

// These 2 functions can confuse the compiler - as it doesn't know if we are calling by reference or by value
// So, better to keep a different name

int main()
{
    int a = 125;
    int b = 843;

    double c = 9.68;
    double d = 9.345;

    string e = "Ramesh";
    string f = "Satyanarayana Reddy";

    cout << "Function Template testing" << endl;
    cout << "======================================================================================" << endl;

    int int_max = maximum_value(a, b);
    cout << "int_max: " << int_max << endl;
    cout << "Outside function:      & " << a << ": " << &a << "     & " << b << ": " << &b << endl;

    double double_max = maximum_value(c, d);
    cout << "double_max: " << double_max << endl;
    cout << "Outside function:      & " << c << ": " << &c << "     & " << d << ": " << &d << endl;

    string string_max = maximum_value(e, f);
    cout << "string_max: " << string_max << endl;
    cout << "Outside function:      & " << e << ": " << &e << "     & " << f << ": " << &f << endl;

    cout << "--------------------------------------------------------------------------------------" << endl;
    cout << endl;

    // Template type deduction and explicit arguments

    cout << "Template type deduction and explicit arguments" << endl;
    cout << "======================================================================================" << endl;

    cout << "maximum_value(" << a << ", " << b << "): " << int_max << "     -> " << "<int> type deduced" << endl;
    cout << "maximum_value(" << c << ", " << d << "): " << double_max << "     -> " << "<double> type deduced" << endl;
    cout << "maximum_value(" << e << ", " << f << "): " << string_max << "     -> " << "<string> type deduced" << endl;
    cout << endl;
    // sometimes, automatic type deduction can cause problems
    // ex: when comparing int and double types. In those cases, we can explicitly mention the type of template argument
    double max1 = maximum_value<double>(c, d);
    cout << "maximum_value(" << c << ", " << d << "): " << max1 << "     -> " << "<double> type mentioned explicitly" << endl;
    double max2 = maximum_value<double>(a, c);
    cout << "maximum_value(" << a << ", " << c << "): " << max2 << "     -> " << "<double> type mentioned explicitly" << endl;
    // double max3 = maximum_value<double>(a, e);     -> error because string cannot be converted to double
    // cout << "maximum_value(" << a << ", " << e << "): " << max3 << "     -> " << "<double> type mentioned explicitly" << endl;

    cout << "--------------------------------------------------------------------------------------" << endl;
    cout << endl;

    // The above ones are parameters by VALUE
    // Now Template type parameters by reference

    cout << "Template type parameters by reference" << endl;
    cout << "======================================================================================" << endl;

    int g = 125;
    int h = 843;

    double i = 9.68;
    double j = 9.345;

    string k = "Ramesh";
    string l = "Satyanarayana Reddy";

    int int_max2 = maximum_reference(g, h);
    cout << "int_max2: " << int_max2 << endl;
    cout << "Outside function:      & " << g << ": " << &g << "     & " << h << ": " << &h << endl;

    double double_max2 = maximum_reference(i, j);
    cout << "double_max2: " << double_max2 << endl;
    cout << "Outside function:      & " << i << ": " << &i << "     & " << j << ": " << &j << endl;

    string string_max2 = maximum_reference(k, l);
    cout << "string_max2: " << string_max2 << endl;
    cout << "Outside function:      & " << k << ": " << &k << "     & " << l << ": " << &l << endl;

    cout << "--------------------------------------------------------------------------------------" << endl;
    cout << endl;

    // Template Specialization - with this, if we send pointers, the function compares actual values else it compares addresses

    cout << "Template Specialization" << endl;
    cout << "======================================================================================" << endl;

    const char * firstname {"Pranay"};
    const char * middlename {"Satvik"};
    const char * greatername = maximum_char(firstname, middlename);
    cout << "Greatername: " << greatername << endl;

    cout << "--------------------------------------------------------------------------------------" << endl;
    cout << endl;

}